<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <link rel="stylesheet" href="graph.css" />
    <script src="https://d3js.org/d3.v3.min.js" ></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>


    </head>
    <body>
</body>
<script>
    let WIDTH = 1000,
        HEIGHT = 500,
        MARGINS = {
            top: 20,
            right: 20,
            bottom: 20,
            left: 50
        }
    async function getPower() {
        let pwrTimeArr = [];
        await $.getJSON('workout-data.json', function(data) {
            var lookInto = data.samples;

            for( let key in lookInto ) {
                let timeOffset = lookInto[key].millisecondOffset;
                let pwrData = lookInto[key].values.power;
                let minutes = ((timeOffset / 1000) / 60);
                //TODO change into a try catch statement
                if(pwrData) {
                    if(pwrData > 500){console.log(pwrData)}
                    let tmpObj = {"time": minutes, "power": pwrData}
                    pwrTimeArr.push(tmpObj);
                }
            }
            console.log(pwrTimeArr);
            $.each(data.samples, function(i, f){

            })

        });
        return pwrTimeArr;
    }

    getPower().then((pwrTimeArr) => {
        let data = pwrTimeArr;
        var width = 1000,   // width of svg
            height = 500,  // height of svg
            padding = 100; // space around the chart, not including labels

        var x_domain = d3.extent(data, function (d) {
                return d.time;
            }),
            y_domain = d3.extent(data, function (d) {
                return d.power;
            });


        // display date format
        //var date_format = d3.time.format("%d %b");

        // create an svg container
        var vis = d3.select("body").append("svg:svg")
            .attr("width", width)
            .attr("height", height);



        // define the y scale  (vertical)
        var yScale = d3.scale.linear()
            .domain(y_domain).nice()   // make axis end in round number
            .range([height - padding, padding]);   // map these to the chart height, less padding.  In this case 300 and 100
        //REMEMBER: y axis range has the bigger number first because the y value of zero is at the top of chart and increases as you go down.


        var xScale2 = d3.time.scale()
            .domain(x_domain)    // values between for month of january
            .range([padding, width - padding]);   // map these sides of the chart, in this case 100 and 600

        let xScale = d3.scale.linear().range([padding, width - padding]).domain([d3.min(data, function (d) {
                return d.time;
            }),
                d3.max(data, function (d) {
                    return d.time;
                })
            ]);


        // define the y axis
        var yAxis = d3.svg.axis()
            .orient("left")
            .scale(yScale);

        // define the x axis
        var xAxis = d3.svg.axis()
            .orient("bottom")
            .scale(xScale);
            //.tickFormat(date_format);

        // draw y axis with labels and move in from the size by the amount of padding
        vis.append("g")
            .attr("class", "axis")
            .attr("transform", "translate(" + padding + ",0)")
            .call(yAxis);

        // draw x axis with labels and move to the bottom of the chart area
        vis.append("g")
            .attr("class", "xaxis axis")  // two classes, one for css formatting, one for selection below
            .attr("transform", "translate(0," + (height - padding) + ")")
            .call(xAxis);

        // now rotate text on x axis
        // solution based on idea here: https://groups.google.com/forum/?fromgroups#!topic/d3-js/heOBPQF3sAY
        // first move the text left so no longer centered on the tick
        // then rotate up to get 45 degrees.
        vis.selectAll(".xaxis text")  // select all the text elements for the xaxis
            .attr("transform", function (d) {
                return "translate(" + this.getBBox().height * -2 + "," + this.getBBox().height + ")rotate(-45)";
            });

        // now add titles to the axes
        vis.append("text")
            .attr("text-anchor", "middle")  // this makes it easy to centre the text as the transform is applied to the anchor
            .attr("transform", "translate(" + (padding / 2) + "," + (height / 2) + ")rotate(-90)")  // text is drawn off the screen top left, move down and out and rotate
            .text("Power");

        vis.append("text")
            .attr("text-anchor", "middle")  // this makes it easy to centre the text as the transform is applied to the anchor
            .attr("transform", "translate(" + (width / 2) + "," + (height - (padding / 3)) + ")")  // centre below axis
            .text("Time (minutes)");

        var lineFunc = d3.svg.line()
            .x(function (d) {
                return xScale(d.time);
            })
            .y(function (d) {
                return yScale(d.power);
            })
            .interpolate('basis');

        vis.append("svg:path")
            .attr("d", lineFunc(data))
            .attr("stroke", "blue")
            .attr("stroke-width", 2)
            .attr("fill", "none");
    });



</script>

<script>

    /*var width = 1000,   // width of svg
        height = 500,  // height of svg
        padding = 100; // space around the chart, not including labels
    async function getPower() {
        let pwrTimeArr = [];
        await $.getJSON('workout-data.json', function(data) {
            var lookInto = data.samples;

            for( let key in lookInto ) {
                let timeOffset = lookInto[key].millisecondOffset;
                let pwrData = lookInto[key].values.power;
                let minutes = ((timeOffset / 1000) / 60);
                //TODO change into a try catch statement
                if(pwrData) {
                    if(pwrData > 500){console.log(pwrData)}
                    let tmpObj = {'x': minutes, 'y': pwrData}
                    pwrTimeArr.push(tmpObj);
                }
            }
            console.log(pwrTimeArr);
            $.each(data.samples, function(i, f){

            })

        });
        return pwrTimeArr;
    }

    getPower().then((pwrTimeArr) => {
        let lineData = pwrTimeArr;
        /!*var vis = d3.select("body").
        append("svg:svg")
            .attr("width", width)
            .attr("height", height);*!/
        let vis = d3.select("#visualisation"),
            WIDTH = 1000,
            HEIGHT = 500,
            MARGINS = {
                top: 20,
                right: 20,
                bottom: 20,
                left: 50
            },
            xRange = d3.scale.linear().range([MARGINS.left, WIDTH - MARGINS.right]).domain([d3.min(lineData, function (d) {
                return d.x;
            }),
                d3.max(lineData, function (d) {
                    return d.x;
                })
            ]),

            yRange = d3.scale.linear().range([HEIGHT - MARGINS.top, MARGINS.bottom]).domain([d3.min(lineData, function (d) {
                return d.y;
            }),
                d3.max(lineData, function (d) {
                    return d.y;
                })
            ]),

            xAxis = d3.svg.axis()
                .scale(xRange)
                .tickSize(5)
                .tickSubdivide(true),

            yAxis = d3.svg.axis()
                .scale(yRange)
                .tickSize(5)
                .orient("left")
                .tickSubdivide(true);


        vis.append("svg:g")
            .attr("class", "x axis")
            .attr("transform", "translate(0," + (HEIGHT - MARGINS.bottom) + ")")
            .call(xAxis);

        vis.append("svg:g")
            .attr("class", "y axis")
            .attr("transform", "translate(" + (MARGINS.left) + ",0)")
            .call(yAxis);

        /!*vis.append("text")
            .attr("class", "x label")
            .attr("text-anchor", "end")
            .attr("x", width)
            .attr("y", height - 6)
            .text("income per capita, inflation-adjusted (dollars)");*!/

        var lineFunc = d3.svg.line()
            .x(function (d) {
                return xRange(d.x);
            })
            .y(function (d) {
                return yRange(d.y);
            })
            .interpolate('basis');

        vis.append("svg:path")
            .attr("d", lineFunc(lineData))
            .attr("stroke", "blue")
            .attr("stroke-width", 2)
            .attr("fill", "none");

        //TODO add titles to axis
        vis.selectAll(".x text")  // select all the text elements for the xaxis
            .attr("transform", function(d) {
                return "translate(" + this.getBBox().height*-2 + "," + this.getBBox().height + ")rotate(-45)";
            });

        // now add titles to the axes
        vis.append("text")
            .attr("text-anchor", "middle")  // this makes it easy to centre the text as the transform is applied to the anchor
            .attr("transform", "translate("+ (padding/2) +","+(height/2)+")rotate(-90)")  // text is drawn off the screen top left, move down and out and rotate
            .text("Power Gain");

        vis.append("text")
            .attr("text-anchor", "middle")  // this makes it easy to centre the text as the transform is applied to the anchor
            .attr("transform", "translate("+ (width/2) +","+(height-(1))+")")  // centre below axis
            .text("Time");

        //axis.ticks(d3.timeMinute.every(15));

    });*/
</script>
</html>
