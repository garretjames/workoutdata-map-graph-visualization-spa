<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Plotly+Leaflet Workout Data Integration</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script src="http://code.jquery.com/jquery-1.7.2.min.js"></script>
    <link rel="stylesheet" href="root.css"/>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.3.4/dist/leaflet.css"
          integrity="sha512-puBpdR0798OZvTTbP4A8Ix/l+A4dHDD0DGqYW6RQ+9jxkRFclaxxQb/SJAWZfWAkuyeQUytO7+7N4QKrDh+drA=="
          crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.3.4/dist/leaflet.js"
            integrity="sha512-nMMmRyTVoLYqjP9hrbed9S+FzjZHW5gY1TWCHA5ckwXZBadntCNs8kEqAWdrb9O7rxbCaA4lKTIWjDXZxflOcA=="
            crossorigin=""></script>
</head>
<body>

<div id="pathMap"></div>
<br/>
<div id="pwrGraph"></div>
</body>
<script>
	//TODO comment code

	const WORKOUT_DATA = "workout-data-sm.json";

	const dataReq = async () => {
		let workoutData = {};
		try {
			let response = await fetch(WORKOUT_DATA);
			workoutData = await response.json();
		} catch (e) {
			alert(e);
			console.log("Error fetching JSON data");
		}
		return processDataReq(workoutData);

	};

	function processDataReq(data) {
		console.log(data);

		//Strip the data down to just the samples to send
		createMap(data.samples);
		createGraph(data.samples);
		console.log(calcPwrAvg(data.samples));
	}

	dataReq();

	function getLatLongs(data, timeBounds) {
		let latLongArr = [];
		let lookInto;

		timeBounds ? lookInto = data.filter((item) => {
			return item.millisecondOffset >= timeBounds[0] && item.millisecondOffset <= timeBounds[1]
		}) : lookInto = data;

		for (let key in lookInto) {
			let latData = lookInto[key].values.positionLat;
			let lonData = lookInto[key].values.positionLong;

			if (latData && lonData) {
				latLongArr.push([latData, lonData]);
			}
		}
		return latLongArr;
	}

	let polyline;

	function createMap(data, timeBounds) {
		//TODO may not need timeBounds var in this method
		const coordsArr = getLatLongs(data, timeBounds);
		console.log(coordsArr);

		var pMap = L.map('pathMap').setView([coordsArr[0][0], coordsArr[0][1]], 13);
		polyline = L.polyline(coordsArr, {color: 'blue'}).addTo(pMap);
		pMap.fitBounds(polyline.getBounds());
		L.tileLayer('https://api.tiles.mapbox.com/v4/{id}/{z}/{x}/{y}.png?access_token={accessToken}', {
			//TODO rewrite this
			attribution: 'Map data &copy; <a href="https://www.openstreetmap.org/">OpenStreetMap</a> contributors, <a href="https://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, Imagery Â© <a href="https://www.mapbox.com/">Mapbox</a>',
			maxZoom: 18,
			id: 'mapbox.streets',
			accessToken: "sk.eyJ1IjoiZ2FycmV0amFtZXMiLCJhIjoiY2pwc25nNW1mMDZxazQybzFmMWZkODh0aiJ9.yaklt83I1FIpv142VljhEg"
		}).addTo(pMap);

	}

	function getPowerStats(data) {
		let pwrTimeArr = [];

		for (let key in data) {
			let timeOffset = data[key].millisecondOffset;
			let pwrData = data[key].values.power;
			let minutes = ((timeOffset / 1000) / 60);

			if (pwrData) {
				pwrTimeArr.push({"time": minutes, "power": pwrData});
			}
		}
		return pwrTimeArr;
	}

	function createGraph(data) {
		const pwrTimeStatsArr = getPowerStats(data);
		let xData = [];
		let yData = [];

		$.each(pwrTimeStatsArr, function (index, value) {
			$.each(value, function (key, value) {
				key === 'time' ? xData.push(value) : yData.push(value)
			})
		});

		let trace1 = {
			x: xData,
			y: yData,
			mode: 'lines',
			name: 'Lines',
			line: {color: '#777'},
			marker: {size: 14}
		}

		let plotData = [trace1];

		let layout = {
			clickmode: 'select',
			dragmode: 'select',
			hovermode: 'closest',
			title: 'Peaks Graph',
			xaxis: {
				title: 'Time (minutes)'
			},
			yaxis: {
				title: 'Power'
			}
		}
		let graphDiv = document.getElementById("pwrGraph");
		Plotly.newPlot(graphDiv, plotData, layout);

		//TODO have click handler reset map to all latlongs
		graphDiv.on('plotly_selected', function (eventData) {
			console.log(eventData.range.x);
			let begMilliTime = (eventData.range.x[0] * 60) * 1000;
			let endMilliTime = (eventData.range.x[1] * 60) * 1000;
			let milliTime = [begMilliTime, endMilliTime];
			let highlightPath = getLatLongs(data, milliTime);

			polyline.setLatLngs(highlightPath);
		});
	}


    let allAvg = [];
    allAvg.push(0);
	function calcPwrAvg(data, timeBounds = [0, 1200000]) {

		let lookInto = data.filter((item) => {
          return item.millisecondOffset >= timeBounds[0] && item.millisecondOffset <= timeBounds[1];
        });
			let pwrSum = 0;
			for (let key in lookInto) {
				let pwrData = lookInto[key].values.power;
                pwrSum += pwrData;
				//TODO better sum function
			}

			let pwrAvg = pwrSum / lookInto.length;
			if (allAvg[0] < pwrAvg) {
				allAvg[0] = pwrAvg;
			}

			//console.log(allAvg);
            //console.log(lookInto[lookInto.length - 1] === data[data.length - 1]);
			return lookInto[lookInto.length - 1] === data[data.length - 1] ? allAvg : calcPwrAvg(data, [timeBounds[0] + 1000, timeBounds[1] + 1000]);
    }

</script>
</html>
